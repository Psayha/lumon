{
  "name": "auth.init",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "auth-init-v2",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 300],
      "webhookId": "auth-init-v2"
    },
    {
      "parameters": {
        "functionCode": "// Parse Telegram initData from webhook body\ntry {\n  const input = $input.item.json;\n  const body = input.body || input;\n  const headers = input.headers || {};\n  const initData = body.initData || '';\n  const appVersion = body.appVersion || '1.0.0';\n\n  // Validate initData is not empty\n  if (!initData || initData.trim().length === 0) {\n    return {\n      json: {\n        error: true,\n        message: 'initData is empty or missing',\n        status: 400\n      }\n    };\n  }\n\n  // Manual parse query string (URLSearchParams not available in n8n)\n  const params = {};\n  initData.split('&').forEach(pair => {\n    if (pair.includes('=')) {\n      const [key, value] = pair.split('=');\n      if (key && value) {\n        params[key] = value;\n      }\n    }\n  });\n\n  // Validate user param exists\n  if (!params.user) {\n    return {\n      json: {\n        error: true,\n        message: 'user parameter is missing in initData',\n        status: 400\n      }\n    };\n  }\n\n  // Parse user data with validation\n  const userStr = decodeURIComponent(params.user);\n  \n  // Check if userStr is valid before parsing\n  if (!userStr || userStr.trim().length === 0) {\n    return {\n      json: {\n        error: true,\n        message: 'user parameter is empty after decoding',\n        status: 400\n      }\n    };\n  }\n\n  let user;\n  try {\n    user = JSON.parse(userStr);\n  } catch (parseError) {\n    return {\n      json: {\n        error: true,\n        message: 'Failed to parse user JSON: ' + parseError.message,\n        raw_user_preview: userStr.substring(0, 100),\n        status: 400\n      }\n    };\n  }\n\n  // Validate user object has required fields\n  if (!user || !user.id) {\n    return {\n      json: {\n        error: true,\n        message: 'user object is missing required id field',\n        status: 400\n      }\n    };\n  }\n\n  return {\n    json: {\n      error: false,\n      telegram_id: user.id.toString(),\n      first_name: user.first_name || '',\n      last_name: user.last_name || '',\n      username: user.username || '',\n      language_code: user.language_code || 'ru',\n      app_version: appVersion,\n      auth_date: params.auth_date || '',\n      ip: headers['x-forwarded-for'] || headers['x-real-ip'] || 'unknown',\n      user_agent: headers['user-agent'] || 'unknown'\n    }\n  };\n} catch (error) {\n  // Unexpected error - return it as json\n  return {\n    json: {\n      error: true,\n      message: 'Unexpected error: ' + error.message,\n      status: 500\n    }\n  };\n}"
      },
      "id": "parse-init-data",
      "name": "Parse Telegram initData",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "has-error",
              "leftValue": "={{ $json.error }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "true"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-parse-error",
      "name": "IF Parse Error",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [550, 300]
    },
    {
      "parameters": {
        "functionCode": "// Format error response from Parse Telegram initData\nconst input = $input.item.json;\n\nreturn {\n  json: {\n    success: false,\n    error: 'invalid_init_data',\n    message: input.message || 'Failed to parse Telegram initData',\n    status: input.status || 400\n  }\n};"
      },
      "id": "format-parse-error",
      "name": "Format Parse Error",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [650, 200]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO users (telegram_id, first_name, last_name, username, language_code, app_version, last_login_at)\nVALUES ({{ $json.telegram_id }}, '{{ $json.first_name }}', '{{ $json.last_name }}', '{{ $json.username }}', '{{ $json.language_code }}', '{{ $json.app_version }}', NOW())\nON CONFLICT (telegram_id) \nDO UPDATE SET \n  first_name = EXCLUDED.first_name,\n  last_name = EXCLUDED.last_name,\n  username = EXCLUDED.username,\n  language_code = EXCLUDED.language_code,\n  app_version = EXCLUDED.app_version,\n  last_login_at = NOW()\nRETURNING id, telegram_id, created_at",
        "options": {}
      },
      "id": "upsert-user",
      "name": "Upsert User",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [750, 400],
      "credentials": {
        "postgres": {
          "id": "supabase-postgres",
          "name": "Supabase PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  uc.role,\n  c.id as company_id,\n  c.name as company_name\nFROM user_companies uc\nJOIN companies c ON c.id = uc.company_id\nWHERE uc.user_id = '{{ $json.id }}' AND uc.is_active = true\nORDER BY uc.created_at ASC\nLIMIT 1",
        "options": {
          "nodeOptions": {
            "continueOnFail": true
          }
        }
      },
      "id": "get-role-company",
      "name": "Get Role & Company",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [850, 300],
      "continueOnFail": true,
      "credentials": {
        "postgres": {
          "id": "supabase-postgres",
          "name": "Supabase PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Generate UUID v4 (manual implementation)\nfunction uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nconst sessionToken = uuidv4();\n\n// Get user data (always present from Upsert User)\nconst userData = $('Upsert User').item.json;\n\n// Try to get role data (might be empty)\nconst roleData = $('Get Role & Company').item?.json || {};\n\n// Set default role if no company assigned\nconst role = roleData.role || 'viewer';\nconst companyId = roleData.company_id || null;\n\nreturn {\n  json: {\n    session_token: sessionToken,\n    user_id: userData.id,\n    company_id: companyId,\n    role: role\n  }\n};"
      },
      "id": "generate-session",
      "name": "Generate Session Token",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO sessions (session_token, user_id, company_id, role, expires_at)\nVALUES ('{{ $json.session_token }}', '{{ $json.user_id }}', {{ $json.company_id ? \"'\" + $json.company_id + \"'\" : \"NULL\" }}, '{{ $json.role }}', NOW() + INTERVAL '7 days')\nRETURNING id, session_token, user_id, company_id, role, created_at, expires_at",
        "options": {}
      },
      "id": "create-session",
      "name": "Create Session",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1250, 300],
      "credentials": {
        "postgres": {
          "id": "supabase-postgres",
          "name": "Supabase PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "insert",
        "schema": {
          "__rl": true,
          "value": "public",
          "mode": "list",
          "cachedResultName": "public"
        },
        "table": {
          "__rl": true,
          "value": "audit_events",
          "mode": "list",
          "cachedResultName": "audit_events"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "user_id": "={{ $('Create Session').item.json.user_id }}",
            "action": "auth.login",
            "resource_type": "session",
            "resource_id": "={{ $('Create Session').item.json.id }}",
            "metadata": "={{ JSON.stringify({ telegram_id: $('Parse Telegram initData').item.json.telegram_id, username: $('Parse Telegram initData').item.json.username, role: $('Create Session').item.json.role }) }}",
            "ip": "={{ $('Parse Telegram initData').item.json.ip }}",
            "user_agent": "={{ $('Parse Telegram initData').item.json.user_agent }}"
          },
          "matchingColumns": [],
          "schema": []
        },
        "options": {}
      },
      "id": "log-audit-event",
      "name": "Log Audit Event",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1450, 400],
      "continueOnFail": true,
      "credentials": {
        "postgres": {
          "id": "OPy15M2cOLEss5yi",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Build response from session data\n// Get session data from Create Session node (not from Log Audit Event)\nconst session = $('Create Session').item.json;\n\nreturn {\n  json: {\n    success: true,\n    data: {\n      session_token: session.session_token,\n      user: {\n        id: session.user_id,\n        role: session.role,\n        company_id: session.company_id\n      },\n      expires_at: session.expires_at\n    }\n  }\n};"
      },
      "id": "build-response",
      "name": "Build Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "functionCode": "// Debug: гарантируем наличие данных перед Respond\nconst input = $input.item.json;\nconst sessionToken = $('Create Session').item.json?.session_token || input?.data?.session_token || null;\n\n// Сохраняем оригинальную структуру из Build Response, но гарантируем наличие session_token\nreturn {\n  json: {\n    success: input.success !== undefined ? input.success : true,\n    data: {\n      session_token: sessionToken,\n      user: input.data?.user || null,\n      expires_at: input.data?.expires_at || null\n    }\n  }\n};"
      },
      "id": "debug-before-respond",
      "name": "Debug Before Respond",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1750, 300]
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond-success",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1850, 300]
    },
    {
      "parameters": {
        "respondWith": "text",
        "responseCode": 400,
        "responseBody": "={{ JSON.stringify($json) }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond-error",
      "name": "Respond Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [650, 500]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Parse Telegram initData",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Telegram initData": {
      "main": [
        [
          {
            "node": "IF Parse Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF Parse Error": {
      "main": [
        [
          {
            "node": "Format Parse Error",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Upsert User",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Parse Error": {
      "main": [
        [
          {
            "node": "Respond Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upsert User": {
      "main": [
        [
          {
            "node": "Get Role & Company",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Role & Company": {
      "main": [
        [
          {
            "node": "Generate Session Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Session Token": {
      "main": [
        [
          {
            "node": "Create Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Session": {
      "main": [
        [
          {
            "node": "Log Audit Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Audit Event": {
      "main": [
        [
          {
            "node": "Build Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Response": {
      "main": [
        [
          {
            "node": "Debug Before Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Before Respond": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}

