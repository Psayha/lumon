{
  "name": "auth.init",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "auth-init-v2",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [250, 300],
      "webhookId": "auth-init-v2"
    },
    {
      "parameters": {
        "functionCode": "// Parse Telegram initData from webhook body\ntry {\n  const input = $input.item.json;\n  const body = input.body || input;\n  const headers = input.headers || {};\n  const initData = body.initData || '';\n  const appVersion = body.appVersion || '1.0.0';\n\n  // Manual parse query string (URLSearchParams not available in n8n)\n  const params = {};\n  initData.split('&').forEach(pair => {\n    const [key, value] = pair.split('=');\n    params[key] = value;\n  });\n\n  // Parse user data\n  const userStr = decodeURIComponent(params.user || '');\n  const user = JSON.parse(userStr);\n\n  return {\n    json: {\n      telegram_id: user.id.toString(),\n      first_name: user.first_name,\n      last_name: user.last_name || '',\n      username: user.username || '',\n      language_code: user.language_code || 'ru',\n      app_version: appVersion,\n      auth_date: params.auth_date,\n      ip: headers['x-forwarded-for'] || headers['x-real-ip'] || 'unknown',\n      user_agent: headers['user-agent'] || 'unknown'\n    }\n  };\n} catch (error) {\n  // If parsing fails, return error that will stop workflow\n  throw new Error('Invalid Telegram initData: ' + error.message);\n}"
      },
      "id": "parse-init-data",
      "name": "Parse Telegram initData",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [450, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO users (telegram_id, first_name, last_name, username, language_code, app_version, last_login_at)\nVALUES ({{ $json.telegram_id }}, '{{ $json.first_name }}', '{{ $json.last_name }}', '{{ $json.username }}', '{{ $json.language_code }}', '{{ $json.app_version }}', NOW())\nON CONFLICT (telegram_id) \nDO UPDATE SET \n  first_name = EXCLUDED.first_name,\n  last_name = EXCLUDED.last_name,\n  username = EXCLUDED.username,\n  language_code = EXCLUDED.language_code,\n  app_version = EXCLUDED.app_version,\n  last_login_at = NOW()\nRETURNING id, telegram_id, created_at",
        "options": {}
      },
      "id": "upsert-user",
      "name": "Upsert User",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [650, 300],
      "credentials": {
        "postgres": {
          "id": "supabase-postgres",
          "name": "Supabase PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  uc.role,\n  c.id as company_id,\n  c.name as company_name\nFROM user_companies uc\nJOIN companies c ON c.id = uc.company_id\nWHERE uc.user_id = '{{ $json.id }}' AND uc.is_active = true\nORDER BY uc.created_at ASC\nLIMIT 1",
        "options": {
          "nodeOptions": {
            "continueOnFail": true
          }
        }
      },
      "id": "get-role-company",
      "name": "Get Role & Company",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [850, 300],
      "continueOnFail": true,
      "credentials": {
        "postgres": {
          "id": "supabase-postgres",
          "name": "Supabase PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Generate UUID v4 (manual implementation)\nfunction uuidv4() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    return v.toString(16);\n  });\n}\n\nconst sessionToken = uuidv4();\n\n// Get user data (always present from Upsert User)\nconst userData = $('Upsert User').item.json;\n\n// Try to get role data (might be empty)\nconst roleData = $('Get Role & Company').item?.json || {};\n\n// Set default role if no company assigned\nconst role = roleData.role || 'viewer';\nconst companyId = roleData.company_id || null;\n\nreturn {\n  json: {\n    session_token: sessionToken,\n    user_id: userData.id,\n    company_id: companyId,\n    role: role\n  }\n};"
      },
      "id": "generate-session",
      "name": "Generate Session Token",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1050, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO sessions (session_token, user_id, company_id, role, expires_at)\nVALUES ('{{ $json.session_token }}', '{{ $json.user_id }}', {{ $json.company_id ? \"'\" + $json.company_id + \"'\" : \"NULL\" }}, '{{ $json.role }}', NOW() + INTERVAL '7 days')\nRETURNING id, session_token, user_id, company_id, role, created_at, expires_at",
        "options": {}
      },
      "id": "create-session",
      "name": "Create Session",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1250, 300],
      "credentials": {
        "postgres": {
          "id": "supabase-postgres",
          "name": "Supabase PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "operation": "insert",
        "schema": {
          "__rl": true,
          "value": "public",
          "mode": "list",
          "cachedResultName": "public"
        },
        "table": {
          "__rl": true,
          "value": "audit_events",
          "mode": "list",
          "cachedResultName": "audit_events"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "user_id": "={{ $('Create Session').item.json.user_id }}",
            "action": "auth.login",
            "resource_type": "session",
            "resource_id": "={{ $('Create Session').item.json.id }}",
            "metadata": "={{ JSON.stringify({ telegram_id: $('Parse Telegram initData').item.json.telegram_id, username: $('Parse Telegram initData').item.json.username, role: $('Create Session').item.json.role }) }}",
            "ip": "={{ $('Parse Telegram initData').item.json.ip }}",
            "user_agent": "={{ $('Parse Telegram initData').item.json.user_agent }}"
          },
          "matchingColumns": [],
          "schema": []
        },
        "options": {}
      },
      "id": "log-audit-event",
      "name": "Log Audit Event",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.4,
      "position": [1450, 400],
      "continueOnFail": true,
      "credentials": {
        "postgres": {
          "id": "OPy15M2cOLEss5yi",
          "name": "Postgres account"
        }
      }
    },
    {
      "parameters": {
        "functionCode": "// Build response from session data\n// Get session data from Create Session node (not from Log Audit Event)\nconst session = $('Create Session').item.json;\n\nreturn {\n  json: {\n    success: true,\n    data: {\n      session_token: session.session_token,\n      user: {\n        id: session.user_id,\n        role: session.role,\n        company_id: session.company_id\n      },\n      expires_at: session.expires_at\n    }\n  }\n};"
      },
      "id": "build-response",
      "name": "Build Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1650, 300]
    },
    {
      "parameters": {
        "functionCode": "// Debug: гарантируем наличие данных перед Respond\nconst input = $input.item.json;\nconst sessionToken = $('Create Session').item.json?.session_token || null;\n\nreturn {\n  json: {\n    ping: true,\n    at: new Date().toISOString(),\n    session_token: sessionToken,\n    success: input.success || true,\n    data: input.data || {\n      session_token: sessionToken,\n      user: input.data?.user || null\n    }\n  }\n};"
      },
      "id": "debug-before-respond",
      "name": "Debug Before Respond",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1750, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond-success",
      "name": "Respond to Webhook",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1850, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseCode": 400,
        "responseBody": "={{ $json }}",
        "options": {
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond-error",
      "name": "Respond Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [650, 500]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Parse Telegram initData",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Telegram initData": {
      "main": [
        [
          {
            "node": "Upsert User",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upsert User": {
      "main": [
        [
          {
            "node": "Get Role & Company",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Role & Company": {
      "main": [
        [
          {
            "node": "Generate Session Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Session Token": {
      "main": [
        [
          {
            "node": "Create Session",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Session": {
      "main": [
        [
          {
            "node": "Log Audit Event",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log Audit Event": {
      "main": [
        [
          {
            "node": "Build Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build Response": {
      "main": [
        [
          {
            "node": "Debug Before Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug Before Respond": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1"
  }
}

